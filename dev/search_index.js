var documenterSearchIndex = {"docs":
[{"location":"modelling/modelling/#Finite-element-modelling","page":"Domain model","title":"Finite element modelling","text":"","category":"section"},{"location":"modelling/modelling/#Element","page":"Domain model","title":"Element","text":"","category":"section"},{"location":"modelling/modelling/#Domain","page":"Domain model","title":"Domain","text":"","category":"section"},{"location":"modelling/modelling/#Domain-constructors","page":"Domain model","title":"Domain constructors","text":"","category":"section"},{"location":"modelling/modelling/#Domain-functions","page":"Domain model","title":"Domain functions","text":"","category":"section"},{"location":"meshing/meshing/#Mesh-generation","page":"Mesh","title":"Mesh generation","text":"","category":"section"},{"location":"meshing/meshing/#Node","page":"Mesh","title":"Node","text":"","category":"section"},{"location":"meshing/meshing/#Node-struct","page":"Mesh","title":"Node struct","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Node","category":"page"},{"location":"meshing/meshing/#Amaru.Node","page":"Mesh","title":"Amaru.Node","text":"Node\n\nA type that represents a finite element node.\n\nFields\n\nid::Int64\nidentification number\ncoord::Amaru.Vec3\ncoordinates vector\ntag::String\nstring tag used to group nodes\ndofs::Vector{Dof}\narray of degrees of freedom\ndofdict::OrderedCollections.OrderedDict{Symbol, Dof}\ndictionary of degrees of freedom\n\n\n\n\n\n","category":"type"},{"location":"meshing/meshing/#Node-constructors","page":"Mesh","title":"Node constructors","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Node()\nNode(::Real,::Real,::Real)\nNode(::AbstractArray)","category":"page"},{"location":"meshing/meshing/#Amaru.Node-Tuple{}","page":"Mesh","title":"Amaru.Node","text":"Node() -> Node\n\n\nConstructs an uninitiallised Node.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.Node-Tuple{Real, Real, Real}","page":"Mesh","title":"Amaru.Node","text":"Node(x::Real) -> Node\nNode(x::Real, y::Real) -> Node\nNode(x::Real, y::Real, z::Real; tag, id) -> Node\n\n\nConstructs an Node with coordinates x, y and z.  A tag string can be provided optionally.\n\nExamples\n\njulia> using Amaru;\njulia> Node(1.0, 2.0, 3.0, tag=\"vertex\")\nNode\n  id: -1\n  coord: [1.0, 2.0, 3.0]\n  tag: \"vertex\"\n  dofs: 0-element Vector{Dof}\n  dofdict: OrderedDict{Symbol, Dof} with 0 entries\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.Node-Tuple{AbstractArray}","page":"Mesh","title":"Amaru.Node","text":"Node(X::AbstractArray; tag, id) -> Any\n\n\nConstructs an Node with coordinates privided in the X vector.  A tag string can be provided optionally.\n\nExamples\n\njulia> using Amaru;\njulia> Node([1.0, 2.0, 3.0], tag=\"vertex\")\nNode\n  id: -1\n  coord: [1.0, 2.0, 3.0]\n  tag: \"vertex\"\n  dofs: 0-element Vector{Dof}\n  dofdict: OrderedDict{Symbol, Dof} with 0 entries\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Node-functions","page":"Mesh","title":"Node functions","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"copy(::Node)\ntag!(::Node, ::String)\ntag!(::Array{Node,1}, ::String)\nadd_dof","category":"page"},{"location":"meshing/meshing/#Base.copy-Tuple{Node}","page":"Mesh","title":"Base.copy","text":"copy(node::Node) -> Node\n\n\nCreates a copy of node.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.tag!-Tuple{Node, String}","page":"Mesh","title":"Amaru.tag!","text":"tag!(object::Node, tag::String)\n\n\nTag a Node object by setting the tag string.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.tag!-Tuple{Vector{Node}, String}","page":"Mesh","title":"Amaru.tag!","text":"tag!(objects, tag)\n\n\nTag all Node objects in an array using the tag string.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.add_dof","page":"Mesh","title":"Amaru.add_dof","text":"add_dof(node::Node, name::Symbol, natname::Symbol)\n\n\nAdds to node a new degree of freedom called name with associated natural variable natname.\n\n\n\n\n\n","category":"function"},{"location":"meshing/meshing/#Cell","page":"Mesh","title":"Cell","text":"","category":"section"},{"location":"meshing/meshing/#Cell-struct","page":"Mesh","title":"Cell struct","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Cell","category":"page"},{"location":"meshing/meshing/#Amaru.Cell","page":"Mesh","title":"Amaru.Cell","text":"Cell\n\nA type that represents a mesh cell. It can be a 1D, 2D or 3D.\n\nFields\n\nid\nidentification number\nshape\ngeometric shape\nnodes\narray of nodes\ntag\nstring tag used to group cells\nquality\ncell quality in the range from 0 to 1\nembedded\ndefines if it is an embedded cell\ncrossed\ndefines if it is a crossed cell\nowner\nowner cell if the cell is a face or edge\nlinked_elems\narray of coupled cells\n\n\n\n\n\n","category":"type"},{"location":"meshing/meshing/#Cell-constructors","page":"Mesh","title":"Cell constructors","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Cell(::CellShape, ::Array{Node,1})","category":"page"},{"location":"meshing/meshing/#Amaru.Cell-Tuple{CellShape, Vector{Node}}","page":"Mesh","title":"Amaru.Cell","text":"Cell(shape, nodes; tag, owner, id)\n\n\nConstructs a Cell given a shape and an array of nodes. A tag string can be provided optionally. If the cell is a face or an edge, the owner element cell can be provided.\n\nExamples\n\njulia> using Amaru;\njulia> nodes = [ Node(0,0), Node(1,0), Node(1,1) ];\njulia> Cell(TRI3, nodes, tag=\"triangle\");\nCell\n  id: -1\n  shape: CellShape  name=\"TRI3\"\n  nodes: 3-element Vector{Node}:\n      1: Node  id=-1\n      2: Node  id=-1\n      3: Node  id=-1\n  tag: \"triangle\"\n  quality: 0.0\n  embedded: false\n  crossed: false\n  owner: nothing\n  linked_elems: 0-element Vector{Amaru.AbstractCell}\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Cell-functions","page":"Mesh","title":"Cell functions","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"copy(::Cell)\ntag!(::Cell, ::String)\ntag!(::Array{Cell,1}, ::String)","category":"page"},{"location":"meshing/meshing/#Base.copy-Tuple{Cell}","page":"Mesh","title":"Base.copy","text":"copy(cell::Cell) -> Cell\n\n\nCreates a copy of cell.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.tag!-Tuple{Cell, String}","page":"Mesh","title":"Amaru.tag!","text":"tag!(object::Cell, tag::String)\n\n\nTag a Cell object by setting the tag string.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.tag!-Tuple{Vector{Cell}, String}","page":"Mesh","title":"Amaru.tag!","text":"tag!(objects, tag)\n\n\nTag all Cell objects in an array using the tag string.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Blocks","page":"Mesh","title":"Blocks","text":"","category":"section"},{"location":"meshing/meshing/#Block-struct","page":"Mesh","title":"Block struct","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Block","category":"page"},{"location":"meshing/meshing/#Amaru.Block","page":"Mesh","title":"Amaru.Block","text":"Block\n\nA type that represents a segment, area or volume and is used to aid the generation of structured meshes by subdivision.\n\nFields\n\nnodes\narray of vertices\nshape\nblock shape\ncellshape\nshape for the resulting cells\nnx\nnumber of divisions in the x direction\nny\nnumber of divisions in the y direction\nnz\nnumber of divisions in the z direction\nrx\ngrowing rate in the x direction\nry\ngrowing rate in the y direction\nrz\ngrowing rate in the z direction\ntag\nstring tag to group blocks\n\n\n\n\n\n","category":"type"},{"location":"meshing/meshing/#Block-constructors","page":"Mesh","title":"Block constructors","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Block(::Array{Real})","category":"page"},{"location":"meshing/meshing/#Amaru.Block-Tuple{Array{Real, N} where N}","page":"Mesh","title":"Amaru.Block","text":"Block(coords::Array; nx, ny, nz, n, rx, ry, rz, r, cellshape, tag, shape) -> Block\n\n\nCreates a 1D, 2D, 3D or surface Block using a coordinates matrix coords for the vertices and  sets the number of divisions (nx, ny, nz) in the x, y and z directions of a local system. The ratios rx, ry and rz set the resulting cells growing rates in the corresponding directions. At the mesh generation stage, the shape of cells will be set according to cellshape (e.g. LIN2, TRI3, QUAD8, HEX8, WED15, etc.). If cellshape is not provided, the cells shape will be set to the lowest degree shape available. A tag string can be provided optionally. This tag will be inherinted by the cells generated from the block. \n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Block-functions","page":"Mesh","title":"Block functions","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"copy(::Block)\ntag!(::Block, ::String)\ntag!(::Array{Block,1}, ::String)\narray(::Block)\nmirror(::Block)\npolar(::Block)\nrotate!(::Block)\nscale!(::Block)\nextrude(::Block)","category":"page"},{"location":"meshing/meshing/#Base.copy-Tuple{Block}","page":"Mesh","title":"Base.copy","text":"copy(block::Block) -> Block\n\n\nCreates a copy of block.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.tag!-Tuple{Block, String}","page":"Mesh","title":"Amaru.tag!","text":"tag!(object::Block, tag::String)\n\n\nTag a Block object by setting the tag string.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.tag!-Tuple{Vector{Block}, String}","page":"Mesh","title":"Amaru.tag!","text":"tag!(objects, tag)\n\n\nTag all Block objects in an array using the tag string.\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.array-Tuple{Block}","page":"Mesh","title":"Amaru.array","text":"array(block; nx, ny, nz, dx, dy, dz)\n\n\nCreates a rectangular array of blocks of size nx×ny×nz using copies of block spaced at dx, dy and dz. The original bĺock is considered as part of the result.\n\nExamples\n\n```julia julia> block = Block([ 0 0; 1 1 ], nx=3, ny=3);\n\njulia> blocks = array(block, nx=2, ny=2, dx=1, dy=1);\n\njulia> length(blocks) 4     ```\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.mirror-Tuple{Block}","page":"Mesh","title":"Amaru.mirror","text":"mirror(block::Amaru.AbstractBlock; axis, base) -> Union{Block, BlockInset}\n\n\nCreates a new Block by mirroring block according to a plane defined by  a normal axis and base point.\n\nExamples\n\njulia> block1 = Block([ 0 0; 2 1; 1 1; 0 1], nx=2, ny=2);\njulia> block2 = mirror(block1, axis=[1,1], base=[2,1])\nBlock\n  nodes: 4-element Vector{Node}:\n    1: Node  id=1\n    2: Node  id=2\n    3: Node  id=3\n    4: Node  id=4\n  shape: CellShape  name=\"QUAD4\"\n  cellshape: CellShape  name=\"QUAD4\"\n  nx: 2\n  ny: 2\n  nz: 1\n  rx: 1.0\n  ry: 1.0\n  rz: 1.0\n  tag: \"\"\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.polar-Tuple{Block}","page":"Mesh","title":"Amaru.polar","text":"polar(block; base, axis, angle, n)\n\n\nCreates a `polar` array using copies of `block` by rotating it\naround `axis` along an `angle` domain. `n` representes \nthe number of cells in the polar direction.\n\n# Examples\n\n```julia\njulia> block = Block([ 0 0; 1 0; 0.707 0.707; 0 1; 0.5 0; 0.924 0.383; 0.382 0.924; 0.354 0.354 ], nx=3, ny=3);\n\njulia> blocks = polar(block, base=[ 0, 0 ,0 ], axis=[ 0, 0, 1 ], angle=360, n=4);\n\njulia> length(blocks)\n4\n```\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#LinearAlgebra.rotate!-Tuple{Block}","page":"Mesh","title":"LinearAlgebra.rotate!","text":"rotate!(bl::Amaru.AbstractBlock; base, axis, angle) -> Amaru.AbstractBlock\n\n\nRotates block an angle (default 90 degrees) around an axis that passes by a base point.\n\nExamples\n\njulia> block = Block([ 0 0; 1 1 ], nx=2, ny=2);\n\njulia> getcoords(block)\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  1.0  0.0\n\njulia> rotate!(block, base=[ 0, 0, 0 ], axis=[ 0, 0, 1], angle=45);\n\njulia> getcoords(block)\n4×3 Matrix{Float64}:\n 0.0       0.0       0.0\n 0.707107  0.707107  0.0\n 0.0       1.41421   0.0\n 0.0       0.707107  0.0\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.scale!-Tuple{Block}","page":"Mesh","title":"Amaru.scale!","text":"scale!(block; factor, base, axis)\n\n\nScales a block from the point base using the given factor. If axis is provided, the scaling is performent only in the  axis direction.\n\nExamples\n\njulia> block = Block([ 0 0; 1 1 ], nx=2, ny=2);\n\njulia> getcoords(block)\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  1.0  0.0\n\njulia> scale!(block, factor=0.5, base=[ 0, 0 ], axis=[ 1, 0 ]);\n\njulia> getcoords(block)\n4×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.5  0.0  0.0\n 0.5  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.extrude-Tuple{Block}","page":"Mesh","title":"Amaru.extrude","text":"extrude(block::Block; axis, length, n) -> Block\n\n\nGets a 3D Block by extruding a 2D block in the direction given by axis and a distance length. It also sets the number of divisions n in the extruded direction.\n\nExamples\n\njulia> block2d = Block([ 0 0; 1 1 ], nx=3, ny=4, cellshape=QUAD8);\njulia> block3d = extrude(block2d, axis=[0,0,1], length=1, n=5)\nBlock\n  nodes: 8-element Vector{Node}:\n    1: Node  id=1\n    2: Node  id=2\n    3: Node  id=3\n    4: Node  id=4\n    5: Node  id=5\n    6: Node  id=6\n    7: Node  id=7\n    8: Node  id=8\n  shape: CellShape  name=\"HEX8\"\n  cellshape: CellShape  name=\"HEX20\"\n  nx: 3\n  ny: 4\n  nz: 5\n  rx: 1.0\n  ry: 1.0\n  rz: 1.0\n  tag: \"\"\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"meshing/meshing/#Mesh-struct","page":"Mesh","title":"Mesh struct","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Mesh","category":"page"},{"location":"meshing/meshing/#Amaru.Mesh","page":"Mesh","title":"Amaru.Mesh","text":"Mesh\n\nA type that represents a finite element mesh.  It contains geometric fields as: nodes, elems, faces, edges, ndim, quality, etc.\n\nFields\n\nndim\nmesh dimensions\nnodes\narray of nodes\nelems\narray of elements (cells)\nfaces\narray of faces (cells)\nedges\narray of edges (cells)\nnode_data\nnodal data dictionary\nelem_data\nelement data dictionary\n_pointdict\n_elempartition\n\n\n\n\n\n","category":"type"},{"location":"meshing/meshing/#Mesh-constructors","page":"Mesh","title":"Mesh constructors","text":"","category":"section"},{"location":"meshing/meshing/","page":"Mesh","title":"Mesh","text":"Mesh(::Array{Real}, ::Array{Array{Int64,1},1}, ::Array{CellShape,1})\nMesh(::Block)","category":"page"},{"location":"meshing/meshing/#Amaru.Mesh-Tuple{Array{Real, N} where N, Vector{Vector{Int64}}, Vector{CellShape}}","page":"Mesh","title":"Amaru.Mesh","text":"Mesh(coordinates, conns)\nMesh(coordinates, conns, cellshapes; tag, verbosity)\n\n\nCreates a Mesh from a nodal coordinates matrix, an array of connectivities and a list of cellshapes. If cellshapes are not provided, they are computed based on the geometry. A tag string for all generated cells can be provided optionally.\n\nExamples\n\njulia> using Amaru;\njulia> C = [ 0 0; 1 0; 1 1; 0 1 ];\njulia> L = [ [ 1, 2, 3 ], [ 1, 3, 4 ] ];\njulia> S = [ TRI3, TRI3 ];\njulia> Mesh(C, L, S, tag=\"triangle\")\n\nMesh\n  ndim: 2\n  nodes: 4-element Vector{Node}:\n    1: Node  id=1\n    2: Node  id=2\n    3: Node  id=3\n    4: Node  id=4\n  elems: 2-element Vector{Cell}:\n    1: Cell  id=1  tag=\"triangle\"\n    2: Cell  id=2  tag=\"triangle\"\n  faces: 4-element Vector{Cell}:\n    1: Cell  id=-1  tag=\"triangle\"\n    2: Cell  id=-1  tag=\"triangle\"\n    3: Cell  id=-1  tag=\"triangle\"\n    4: Cell  id=-1  tag=\"triangle\"\n  edges: 4-element Vector{Cell}:\n    1: Cell  id=-1  tag=\"triangle\"\n    2: Cell  id=-1  tag=\"triangle\"\n    3: Cell  id=-1  tag=\"triangle\"\n    4: Cell  id=-1  tag=\"triangle\"\n  node_data: OrderedDict{String, Array} with 1 entry\n    \"node-id\" => [1, 2, 3, 4]\n  elem_data: OrderedDict{String, Array} with 3 entries\n    \"quality\" => [0.8915188114208271, 0.8915188114208271]\n    \"elem-id\" => [1, 2]\n    \"cell-type\" => [5, 5]\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Amaru.Mesh-Tuple{Block}","page":"Mesh","title":"Amaru.Mesh","text":"Mesh(items; genfacets, genedges, reorder, verbosity)\n\n\nGenerates a Mesh based from a set of items that can be  Block or Mesh objects, or a combination of both. If reorder is true (default), the nodes are ordered using the Cuthill–McKee algorithm. The mesh generation steps are printed in stdout. The printed output can be set to verbose or silent.\n\nExamples\n\njulia> using Amaru;\njulia> B1 = Block([0 0; 1 1], nx=2, ny=2);\njulia> B2 = Block([1 0; 2 1], nx=3, ny=2);\njulia> Mesh(B1, B2, verbosity=0)\nMesh\n  ndim: 2\n  nodes: 18-element Vector{Node}:\n    1: Node  id=1\n    2: Node  id=2\n    3: Node  id=3\n    4: Node  id=4\n    ⋮\n    15: Node  id=15\n    16: Node  id=16\n    17: Node  id=17\n    18: Node  id=18\n  elems: 10-element Vector{Cell}:\n    1: Cell  id=1\n    2: Cell  id=2\n    3: Cell  id=3\n    4: Cell  id=4\n    ⋮\n    7: Cell  id=7\n    8: Cell  id=8\n    9: Cell  id=9\n    10: Cell  id=10\n  faces: 14-element Vector{Cell}:\n    1: Cell  id=-1\n    2: Cell  id=-1\n    3: Cell  id=-1\n    4: Cell  id=-1\n    ⋮\n    11: Cell  id=-1\n    12: Cell  id=-1\n    13: Cell  id=-1\n    14: Cell  id=-1\n  edges: 14-element Vector{Cell}:\n    1: Cell  id=-1\n    2: Cell  id=-1\n    3: Cell  id=-1\n    4: Cell  id=-1\n    ⋮\n    11: Cell  id=-1\n    12: Cell  id=-1\n    13: Cell  id=-1\n    14: Cell  id=-1\n  node_data: OrderedDict{String, Array} with 1 entry\n    \"node-id\" => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n  elem_data: OrderedDict{String, Array} with 3 entries\n    \"quality\" => 10-element Vector{Float64}\n    \"elem-id\" => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \"cell-type\" => [9, 9, 9, 9, 9, 9, 9, 9, 9, 9]\n\n\n\n\n\n","category":"method"},{"location":"meshing/meshing/#Mesh-functions","page":"Mesh","title":"Mesh functions","text":"","category":"section"},{"location":"modelling/mech/mech/#Mechanical-Analysis","page":"Mechanical analysis","title":"Mechanical Analysis","text":"","category":"section"},{"location":"modelling/mech/mech/#Elements","page":"Mechanical analysis","title":"Elements","text":"","category":"section"},{"location":"modelling/mech/mech/","page":"Mechanical analysis","title":"Mechanical analysis","text":"Amaru.MechSolid\nAmaru.MechRod\nAmaru.MechRodSolidJoint","category":"page"},{"location":"modelling/mech/mech/#Amaru.MechSolid","page":"Mechanical analysis","title":"Amaru.MechSolid","text":"MechSolid\n\nA bulk finite element for mechanical equilibrium analyses.\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.MechRod","page":"Mechanical analysis","title":"Amaru.MechRod","text":"MechRod\n\nA line finite element for mechanical equilibrium analyses.\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.MechRodSolidJoint","page":"Mechanical analysis","title":"Amaru.MechRodSolidJoint","text":"MechRodSolidJoint\n\nAn interface element to link MechRod elements to bulk elements in mechanical equilibrium analyses.\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Material-models","page":"Mechanical analysis","title":"Material models","text":"","category":"section"},{"location":"modelling/mech/mech/","page":"Mechanical analysis","title":"Mechanical analysis","text":"ElasticSolid\nElasticSolid()\nAmaru.ElasticSolidIpState","category":"page"},{"location":"modelling/mech/mech/#Amaru.ElasticSolid","page":"Mechanical analysis","title":"Amaru.ElasticSolid","text":"ElasticSolid\n\nA type for linear elastic materials.\n\nFields\n\nE::Float64\nYoung Modulus\nnu::Float64\nPoisson ratio\nρ::Float64\nDensity\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.ElasticSolid-Tuple{}","page":"Mechanical analysis","title":"Amaru.ElasticSolid","text":"ElasticSolid(; E, nu, rho)\n\n\nCreates an ElasticSolid material type\n\nArguments\n\nE: Young modulus\nnu: Poisson ratio\nrho: Density\n\n\n\n\n\n","category":"method"},{"location":"modelling/mech/mech/#Amaru.ElasticSolidIpState","page":"Mechanical analysis","title":"Amaru.ElasticSolidIpState","text":"ElasticSolidIpState\n\nA type for the state data of a ElasticSolid type.\n\nFields\n\nenv::ModelEnv\nEnvironment information\nσ::Vector{Float64}\nStress tensor\nε::Vector{Float64}\nStrain tensor\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/","page":"Mechanical analysis","title":"Mechanical analysis","text":"DruckerPrager\nDruckerPrager()\nAmaru.DruckerPragerIpState","category":"page"},{"location":"modelling/mech/mech/#Amaru.DruckerPrager","page":"Mechanical analysis","title":"Amaru.DruckerPrager","text":"DruckerPrager\n\nA type for linear elastic materials with Drucker Prager failure criterion.\n\nFields\n\nE::Float64\nYoung Modulus\nν::Float64\nPoisson ratio\nα::Float64\nDrucker Prager alpha paramter\nκ::Float64\nDrucker Prager kappa paramter\nH::Float64\nHardening parameter\nρ::Float64\nDensity\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.DruckerPrager-Tuple{}","page":"Mechanical analysis","title":"Amaru.DruckerPrager","text":"DruckerPrager(; E, nu, alpha, kappa, H, rho)\n\n\nCreates an DruckerPrager material type\n\nArguments\n\nE: Young modulus\nnu: Poisson ratio\nalpha: Drucker Prager alpha parameter\nkappa: Drucker Prager kappa parameter\nH: Hardening parameter\nrho: Density\n\n\n\n\n\n","category":"method"},{"location":"modelling/mech/mech/#Amaru.DruckerPragerIpState","page":"Mechanical analysis","title":"Amaru.DruckerPragerIpState","text":"DruckerPragerIpState\n\nA type for the state data of a DruckerPrager type.\n\nFields\n\nenv::ModelEnv\nEnvironment information\nσ::Vector{Float64}\nStress tensor\nε::Vector{Float64}\nStrain tensor\nεpa::Float64\nAccumulated plastic strain\nΔγ::Float64\nPlastic multiplier\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/","page":"Mechanical analysis","title":"Mechanical analysis","text":"VonMises\nVonMises()\nAmaru.VonMisesIpState","category":"page"},{"location":"modelling/mech/mech/#Amaru.VonMises","page":"Mechanical analysis","title":"Amaru.VonMises","text":"VonMises\n\nA type for linear elastic materials with Von Mises failure criterion.\n\nFields\n\nE::Float64\nYoung modulus\nν::Float64\nPoisson ratio\nσy::Float64\nYielding stress\nH::Float64\nHardening parameter\nρ::Float64\nDensity\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.VonMises-Tuple{}","page":"Mechanical analysis","title":"Amaru.VonMises","text":"VonMises(; E, nu, fy, H, rho)\n\n\nCreates an VonMises material type\n\nArguments\n\nE: Young modulus\nnu: Poisson ratio\nfy: Yielding stress\nH: Hardening parameter\nrho: Density\n\n\n\n\n\n","category":"method"},{"location":"modelling/mech/mech/#Amaru.VonMisesIpState","page":"Mechanical analysis","title":"Amaru.VonMisesIpState","text":"DruckerPragerIpState\n\nA type for the state data of a DruckerPrager type.\n\nFields\n\nenv::ModelEnv\nEnvironment information\nσ::Vector{Float64}\nStress tensor\nε::Vector{Float64}\nStrain tensor\nεpa::Float64\nAccumulated plastic strain\nΔγ::Float64\nPlastic multiplier\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/","page":"Mechanical analysis","title":"Mechanical analysis","text":"ElasticRod\nElasticRod()\nAmaru.ElasticRodIpState","category":"page"},{"location":"modelling/mech/mech/#Amaru.ElasticRod","page":"Mechanical analysis","title":"Amaru.ElasticRod","text":"ElasticRod\n\nA type for linear elastic materials in rods.\n\nFields\n\nE::Float64\nYoung Modulus\nA::Float64\nSection area\nρ::Float64\nDensity\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.ElasticRod-Tuple{}","page":"Mechanical analysis","title":"Amaru.ElasticRod","text":"ElasticRod(; E, A, dm, rho)\n\n\nCreates an ElasticRod material type\n\nArguments\n\nE: Young modulus\nA: Section area\ndm: Diameter (only if A is not provided)\nrho: Density\n\n\n\n\n\n","category":"method"},{"location":"modelling/mech/mech/#Amaru.ElasticRodIpState","page":"Mechanical analysis","title":"Amaru.ElasticRodIpState","text":"ElasticRodIpState\n\nA type for the state data of a ElasticRod type.\n\nFields\n\nenv::ModelEnv\nenvironment information\nσ::Float64\nAxial stress\nε::Float64\nAxial strain\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/","page":"Mechanical analysis","title":"Mechanical analysis","text":"PPRod\nPPRod()\nAmaru.PPRodIpState","category":"page"},{"location":"modelling/mech/mech/#Amaru.PPRod","page":"Mechanical analysis","title":"Amaru.PPRod","text":"PPRod\n\nA type for linear elastic perfectly plastic materials in rods.\n\nFields\n\nE::Float64\nYoung modulus\nA::Float64\nSection area\nσy0::Float64\nYielding stress\nH::Float64\nHardening parameter\nρ::Float64\nDensity\n\n\n\n\n\n","category":"type"},{"location":"modelling/mech/mech/#Amaru.PPRod-Tuple{}","page":"Mechanical analysis","title":"Amaru.PPRod","text":"PPRod(; E, A, fy, sig_y, H, rho, dm)\n\n\nCreates an PPRod material type\n\nArguments\n\nE: Young modulus\nA: Section area\ndm: Diameter (only if A is not provided)\nfy: Yielding stress\nH: Hardening parameter\nrho: Density\n\n\n\n\n\n","category":"method"},{"location":"modelling/mech/mech/#Amaru.PPRodIpState","page":"Mechanical analysis","title":"Amaru.PPRodIpState","text":"ElasticRodIpState\n\nA type for the state data of a PPRod type.\n\nFields\n\nenv::ModelEnv\nσ::Float64\nε::Float64\nεp::Float64\nΔγ::Float64\n\n\n\n\n\n","category":"type"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using Amaru\nend","category":"page"},{"location":"#Introduction-to-Amaru","page":"Introduction","title":"Introduction to Amaru","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Amaru is a Finite Element library written in Julia language. The purpose of this library is to aid the research of new algorithms for the finite element method. Currently this library solves static and dynamic analysis in two and three-dimensions.","category":"page"},{"location":"#Installation-and-basic-usage","page":"Introduction","title":"Installation and basic usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install the package using the package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Amaru","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To use Amaru, type:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Amaru","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To test:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] test Amaru","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Amaru\nDocTestSetup = quote\n    using Amaru\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru","category":"page"},{"location":"tutorial/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/tutorial/#Mesh-generation","page":"Tutorial","title":"Mesh generation","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"A mesh is mainly composed by cells and nodes. in Amaru, a mesh is also composed by surface cells and surface edges and are computed at the time of mesh generation.","category":"page"},{"location":"tutorial/tutorial/#Nodes","page":"Tutorial","title":"Nodes","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"A node is represented by an instance of the Node type. It contains the node coordinates, a identification number and a tag string that can be used to label a group of nodes.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\nnode = Node(1.0, 2.0, 0.0, id=1, tag=\"vertex\")","category":"page"},{"location":"tutorial/tutorial/#Cells","page":"Tutorial","title":"Cells","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"A mesh cell is represented by an instace of the Cell type. It is defined by a given shape object,  a list of nodes, a identification number an a tag string. The shape object contains information related with the geometry of a finite element.  For example, a TRI3 shape represents the shape of a linear triangular  finite element.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru;\nnode1 = Node(0.0, 0.0, id=1)\nnode2 = Node(1.0, 0.0, id=2)\nnode3 = Node(1.0, 1.0, id=3)\nnodes = [ node1, node2, node3 ]\n\nCell(TRI3, nodes, id=1, tag=\"triangle\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are many shapes defined in Amaru, for instance:  LIN2, LIN3, TRI3, TRI6, QUAD4, QUAD8, QUAD9 TET4, TET10, PYR5, WED6, WED15, HEX8, HEX20, HEX27, etc.","category":"page"},{"location":"tutorial/tutorial/#Blocks","page":"Tutorial","title":"Blocks","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Blocks are entities used to aid the generation of structured meshes in 1D, 2D and 3D. A Block type represents a geometric segment, area (4 or 8 point quadrilateral) or volume (8 or 20 point hexahedron). An instance of the block type  is generated from a coordinates matrix and predefined number of divisions divisions (nx, ny, nz) in the x, y and z directions of a local system. The block below represents a 2D Block with nx=7 and ny=5. The mplot function saves the block image to a file in svg format. Other formats as pdf and png can be used.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\nblock = Block([0 0; 4 0; 3 2; 1 2], nx=7, ny=5)\nmplot(block, \"block.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Blocks can be combined to define a complex geometry. To manipulate blocks, Amaru provides several operators as copy, move!, scale!, rotate, mirror, array, polar, extrude, etc.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, let's generate a square mesh with a central hole. We start with a quadratic quadrilateral block. Note that  the vertex coordinates follow the same numbering as conventional finite elements. Thus, the corner nodes are listed first, and then the middle nodes. All the nodes are listed couterclockwise.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nblock1 = Block(\n    [ \n        0.0      0.0    \n        0.7643   0.7643 \n        0.6667   1.0    \n        0.0      1.0    \n        0.38215  0.38215\n        0.692    0.8724 \n        0.3333   1.0    \n        0.0      0.5 \n    ],\n    cellshape=QUAD8, nx=5, ny=5 \n)\nmplot(block1, \"block1.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"A mirror operation can be applyed to this block to get a second one. Then, both blocks can be grouped in an array for further manipulation.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"block2 = mirror(block1, base=[0, 0], axis=[0.7643, -0.7643])\nblocks = [block1, block2]\nmplot(blocks, \"blocks.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The center of the circle that contains the arc is located at the coordinates (1,1). To place the center at the origin (0,0) we perform a move! operation.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"move!(blocks, dx=-1.0, dy=-1.0)\nmplot(blocks, \"moved.svg\", markers=true, axis=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we can apply a polar operation to the current geometry to  obtain the square region with a central hole. Note that the original geometry was replicated four times (n=4) with different rotation angles. For this purpose a rotation axis and a base point were employed.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"hole = polar(blocks, base=[0, 0], axis=[0, 0, 1], angle=360, n=4)\nmplot(hole, \"hole.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, an extrude operation is used to obtain a volume following a defined axis and length. The argument n=4 represents the number of divisions intended along the new dimension.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"solid = extrude(hole, axis=[0, 0, 1], length=1, n=4)\nmplot(solid, \"solid.svg\", markers=true, dist=13)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that, the solid variable is an array with four blocks, as shown in the figure. This array is used to generate the structured mesh.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"mesh = Mesh(solid)\nmplot(mesh, \"mesh.svg\", dist=13)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, a smooth operation can be applied to improve the cells quality.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"smooth_mesh = smooth!(mesh)\nmplot(smooth_mesh, \"smooth_mesh.svg\", dist=13)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Mesh-generation-examples","page":"Tutorial","title":"Mesh generation examples","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Below are presented some examples of structured mesh generation using Amaru.","category":"page"},{"location":"tutorial/tutorial/#Simple-2D-mesh","page":"Tutorial","title":"Simple 2D mesh","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nblock = Block([0 0 ; 2 2], nx=8, ny=6)\nmesh  = Mesh(block) \nmplot(mesh, \"mesh-quad4.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Mesh-with-quadratic-cells","page":"Tutorial","title":"Mesh with quadratic cells","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nblock = Block([0 0 ; 2 2], nx=8, ny=6, cellshape=QUAD8)\nmesh  = Mesh(block) \nmplot(mesh, \"mesh-quad8.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Simple-3D-mesh","page":"Tutorial","title":"Simple 3D mesh","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\nblock = Block([0 0 0; 2 4 3], nx=3, ny=6, nz=6)\nmesh = Mesh(block)\nmplot(mesh, \"mesh-hex8.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#D-mesh-constructed-from-two-quadratic-blocks","page":"Tutorial","title":"2D mesh constructed from two quadratic blocks","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\nblock1 = Block(\n    [ \n        0.0      0.0    \n        0.7643   0.7643 \n        0.6667   1.0    \n        0.0      1.0    \n        0.38215  0.38215\n        0.692    0.8724 \n        0.3333   1.0    \n        0.0      0.5 \n    ],\n    cellshape=QUAD8, nx=5, ny=5\n)\nblock2 = mirror(block1, base=[0, 0], axis=[0.7643, -0.7643])\nmesh = Mesh(block1, block2)\nmplot(mesh, \"mesh-2d.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Mesh-with-cells-growing-in-the-x-direction","page":"Tutorial","title":"Mesh with cells growing in the x direction","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nR = 5.0\nr = 1.0\n\nblock = BlockGrid(\n    [ 0.0, r, R ], \n    [ 0.0, R ], \n    nx=[ 4, 8 ], \n    ny=[ 8 ], \n    rx=[ 1, 1.2] # elements growing rate in the x direction\n)\n\nmesh = Mesh(block)\nmplot(mesh, \"mesh-rate.svg\", markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#D-mesh-obtained-revolving-the-last-example","page":"Tutorial","title":"3D mesh obtained revolving the last example","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"mesh = revolve(mesh, minangle=0, maxangle=90)\nchangeaxes!(mesh, \"xzy\")\nrotate!(mesh, axis=[0,0,1], angle=90)\nmplot(mesh, \"mesh-rev.svg\", azim=-45) \nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Wire-mesh","page":"Tutorial","title":"Wire mesh","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nblock1 = Block([0 0 0; 1 0 1; 0.7 0 0.3 ], n=7) # curved wire (quadratic)\nblock2 = Block([1 0 1; 1 0 2], n=5) # straight wire\nmesh = Mesh(block1, block2)\n\nmplot(mesh, \"mesh-arc.svg\", azim=-90, elev=0, markers=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#D-mesh-obtained-revolving-the-last-example-2","page":"Tutorial","title":"3D mesh obtained revolving the last example","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"mesh = revolve(mesh, n=24, axis=[0,0,1]) # surface by revolution\nmplot(mesh, \"mesh-surf.svg\", elev=15)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Finite-element-model","page":"Tutorial","title":"Finite element model","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"To performe a finite element analysis, an instance of the Domain type is required. This represents the domain model and contains nodes and finite elements. The element instances are different from the cells in a Mesh object since the elements are constructed according to the analysis problem. To instantiate a Domain object a mesh and a list of material models objects are needed. The Domain type is used for all analysis problems, e.g. mechanical, thermal, seepage, etc. Thus, for a particular problem, a consistent list of materials should be used. For example, in a mechanical analysis, all elements should be associated to mechanical material types. Based on the choosen materials, the Domain object will setup the corresponding finite elements and degrees of freedom.","category":"page"},{"location":"tutorial/tutorial/#Material-definitions","page":"Tutorial","title":"Material definitions","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are several material models implemented in Amaru and are associated to a corresponding type, e.g.  ElasticSolid, DruckerPrager, VonMises, ElasticRod, etc. A particular material instance is defined by calling the construcor with set of corresponding parameters.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nsteel = ElasticSolid(E=2e8, nu=0.2) # E in kPa\nrock = DruckerPrager(E=2e8, nu=0.2, alpha=0.4, kappa=2500, H=1e4)\nrebar = ElasticRod(E=2e8, A=1e-4)\n\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/#Model-generation","page":"Tutorial","title":"Model generation","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The following example shows the walk through of creating a Domain object. Note that the list of materials contains a pair relating a domain region  to material instance.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\n# Mesh generation\nblock = Block([0 0 0; 1 0.1 0.1], nx=20, ny=2, nz=2, cellshape=HEX20)\nmesh = Mesh(block)\n\n# Analysis model\nsteel = ElasticSolid(E=2e8, nu=0.2) # E in kPa\n\nmaterials = [\n    :(x>=0) => steel,\n]\nmodel = Domain(mesh, materials)\n\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/#Boundary-conditions","page":"Tutorial","title":"Boundary conditions","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The boundary conditions are given by objects that define the quantities that should be applied to nodes, faces, edges or even elements (NodeBC, FaceBC, EdgeBC and ElementBC).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The example below shows a nodal boundary condition where all displacements are set to zero.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nfixed_end = NodeBC(ux=0, uy=0, uz=0)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This other example shows a face boudary condition where a traction is applied in the negative z direction.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nload = FaceBC(tz=-10)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The keys (e.g. ux, tz, etc.) to be set in a boundary condition are related to the analysis problem, and ultimately to the material types in use. For example, in a mechanical analysis, the keys for nodal boundary conditions are ux, uy, uz, fx, fy and fz where ux represents displacement and fx concentrated force, both in the x direction. Similarly, the keys for a face boudary condition are ux, uy, uz, tx, ty and tz, where tx is a traction (force per area) in the x direction. Besides, the tn key can be used to apply traction normal to the face.","category":"page"},{"location":"tutorial/tutorial/#Analysis-example","page":"Tutorial","title":"Analysis example","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This example shows a mechanical analysis in a steel beam. The left end was clamped, thus all displacements at x==0 are set to zero. Also, a vertical traction is applied at the right end. The solve! function performs the calculations of a Domain instance subjected to a set of boundary conditions. The function also updates the state variables at the elements' integration points.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For post-processing in a visualization software (e.g. Paraview), the  model can save the current per node and per element values (e.g. displacements, stresses, etc.) in \"vtk\" and \"vtu\" formats.  To save the full state of a domain model, the output in \"xml\" format is also supported; thus, the model can be reused in future analyses.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\n# Mesh generation\nblock = Block([0 0 0; 1 0.1 0.1], nx=20, ny=2, nz=2, cellshape=HEX8)\nmesh = Mesh(block)\n\n# Analysis model\nsteel = ElasticSolid(E=200e6, nu=0.2) # E in kPa\n\nmaterials = [\n    :(x>=0) => steel,\n]\nmodel = Domain(mesh, materials)\n\nbcs = [\n    :(x==0) => NodeBC(ux=0, uy=0, uz=0)\n    :(x==1) => FaceBC(tz=-1000)\n]\n\nsolve!(model, bcs, verbosity=2)\nsave(model, \"beam.vtu\")\n\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The mplot function allow to save a plot of the domain in several formats (e.g. \"pdf\", \"svg\", \"png\", etc.). In this case, the deformed state is plot using a mangnification scale of 100. Also the u_y field is displayed and the corresponding label is placed next to the colorbar. To adjunst the point of view, the azim, elev and dist parameters can be set. They represent, respectively, the azimut, elevation angle and distance to the rendered domain.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"mplot(model, \"beam.svg\", warpscale=100, field=:uz, colorbarlabel=raw\"u_z\", colorbarscale=0.4, azim=-90, elev=30, dist=7)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Nonlinear-analysis","page":"Tutorial","title":"Nonlinear analysis","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The use of material models with nonlinear behavior lead to a nonlinear analyses. For example, the VonMises material type represents a nonlinear material model. For the analysis, the number of increments can be adjusted using the nincs parameter. Also, the autoinc parameter can be set to true to le the solve! function to  automatically compute and recompute the increment sizes. The tol paramter specifies the maximum force discrepancy between internal and external forces.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\n# Mesh generation\nblock = Block([0 0 0; 1 0.1 0.1], nx=20, ny=2, nz=3, cellshape=HEX8)\nmesh = Mesh(block)\n\n# Analysis model\nsteel1 = ElasticSolid(E=2e8, nu=0.2) # E in kPa\nsteel2 = VonMises(E=2e8, nu=0.2, fy=500e3, H=1e4)\n\nmaterials = [\n    :(x>=0.5) => steel1,\n    :(x<=0.5) => steel2\n]\nmodel = Domain(mesh, materials)\n\nbcs = [\n    :(x==0) => NodeBC(ux=0, uy=0, uz=0)\n    :(x==1) => FaceBC(uz=-0.04)\n]\n\nsolve!(model, bcs, tol=0.01, autoinc=true)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"mplot(model, \"beam-vm.svg\", warpscale=10, field=:sxx, fieldmult=1e-3, colorbarlabel=raw\"$\\sigma_{xx}$\", colorbarscale=0.4, azim=-90, dist=7)\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Loggers","page":"Tutorial","title":"Loggers","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Loggers are objects designed to track the information of nodes, integration points, faces, edges, points and segments. That information is updated at every increment and can be saved to a file.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nnodelog = NodeLogger(\"nodelog.table\")\niplog = IpLogger(\"nodelog.table\")\nfacelog = FacesSumLogger(\"nodelog.table\")\nnodeslog = NodeGroupLogger(\"nodes.book\")\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The loggers need to be associated to the entity they track by using a filter expression,  coordinates or a tag string.  Finally, the loggers have to be linked to a Domain object by using the setloggers! function.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\n# Mesh generation\nblock = Block([0 0 0; 1 0.1 0.1], nx=20, ny=2, nz=3, cellshape=HEX8)\nmesh = Mesh(block)\n\n# Analysis model\nsteel1 = ElasticSolid(E=2e8, nu=0.2) # E in kPa\nsteel2 = VonMises(E=2e8, nu=0.2, fy=500e3, H=1e4)\n\nmaterials = [\n    :(x>=0.5) => steel1,\n    :(x<=0.5) => steel2\n]\nmodel = Domain(mesh, materials)\n\nbcs = [\n    :(x==0) => NodeBC(ux=0, uy=0, uz=0)\n    :(x==1) => FaceBC(uz=-0.04)\n]\n\nloggers = [\n    :(x==1) => FacesSumLogger(\"tip.table\"),\n    [0.05, 0.05, 0.1] => IpLogger(\"ip.table\"),\n    :(y==0.1 && z==0.1) => NodeGroupLogger(\"topgroup.book\"),\n    [0 0.05 0.1; 1 0.05 0.1] => SegmentLogger(\"top.book\", n=40),\n    [0 0.05 0.0; 1 0.05 0.0] => SegmentLogger(\"bottom.book\", n=40),\n]\n\nsetloggers!(model, loggers)\n\nsolve!(model, bcs, tol=0.01, nouts=2, autoinc=true)\n\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The loggers are classified single loggers and group loggers. Single loggers record a table of data. Group loggers record a book, which is a set of tables. Once the analysis is finished, the loggers data can be recovered in another script  calling the constructors of the types DataTable and DataBook.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\ntip = DataTable(\"tip.table\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\nlong = DataBook(\"topgroup.book\").tables[end]","category":"page"},{"location":"tutorial/tutorial/#Plotting","page":"Tutorial","title":"Plotting","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Amaru provides a chart ploting function cplot to ease the visualization of the data stored in DataTable and DataBook objects.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Amaru\n\ntip = DataTable(\"tip.table\")\ncplot(\n    [\n        (x=tip.uz, y=tip.fz, marker=\"o\"),\n    ],\n    filename = \"uz_vs_fz.svg\",\n    xmult  = 1e3,\n    xlabel = raw\"$u_z$ [mm]\",\n    ylabel = raw\"$f_z$ [kN]\",\n)\n\ntopgroup = DataBook(\"topgroup.book\").tables[end]\ncplot(\n    [\n        (x=topgroup.x, y=topgroup.uz, marker=\"o\"),\n    ],\n    filename = \"x_vs_uz.svg\",\n    ymult  = 1e3,\n    xlabel = raw\"$x$ [m]\",\n    ylabel = raw\"$u_z$ [mm]\",\n)\n\ntop = DataBook(\"top.book\").tables[end]\nbottom = DataBook(\"bottom.book\").tables[end]\ncplot(\n    [\n        (x=top.x, y=top.sxx, marker=\"o\", label=\"top\"),\n        (x=bottom.x, y=bottom.sxx, marker=\"o\", label=\"bottom\"),\n    ],\n    filename = \"x_vs_sxx.svg\",\n    ymult  = 1e-3,\n    xlabel = raw\"$x$ [m]\",\n    ylabel = raw\"$\\sigma_{xx}$ [MPa]\",\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"}]
}
